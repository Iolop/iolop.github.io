---
layout: post
title: CS:APP读书笔记-3-程序的机器级表示
date: 2024-03-13 21:31 +0800
categories: [CS:APP]
tags: [读书笔记]
math: true
---

# 第三章：程序的机器级表示

面对现在的可执行文件，我们千头万绪不知道该怎么去理解它。在Windows上，我们知道双击去运行它；Linux上，我们可以在命令行中通过`./file`的形式去执行。这一章，我们将会走进程序的机器级表示，来理解代码时如何被转变成CPU可以理解的模式的，我们又是如何来表示我们在源代码中的各种数据，而CPU又是如何访问它们。除此外，我们还将学习到我们常用的流程控制又是如何实现。以上这些内容采用C语言进行描述以及通过gcc编译出的各类中间文件进行解释，其他的类型比如虚拟机、JIT、解释器类型语言不在此列。

## CPU的演化

要理解可执行文件是怎么运行的，我们有必要先回头去看看CPU的演化过程。再最早时期，也许你曾看到书上提到一种打孔程序机[^punched-card]。这种形式后来被汇编代码所取代，因为汇编代码更容易被人们记忆。再后来，随着CPU的发展，我们拥有了更强的性能和更广阔的可用空间，随之演变的是更抽象的语言——我们现在常用的高级语言。简单的来看，我们把这三种演化的关系：机器码——汇编代码——高级语言，可以映射到如今的源代码到可执行代码的翻译之路上：编译——汇编——链接。

以前常说的x86，其实是Intel的32位处理器，可惜Intel没把握住64这个风口，让AMD先一步迈了出去，先有了amd64(注意和arm64不是同一个东西)，然后Intel跟进，出现了x86-64(强行更名)。

## 程序编码

通过如下命令，我们可以编译源代码到可执行文件

```shell
gcc -Og -o hello hello.c
```

gcc是我们之前说的一整套工具，这是Linux上的默认编译器。通过上述命令，gcc会自动地帮助你执行一系列地命令来完成预处理、编译、汇编、链接过程。

1. 预处理：完成对源文件的拓展，插入头文件。
2. 编译：通过编译器，转化位汇编代码，产生`.s`文件。
3. 汇编：将汇编代码转化成二进制目标代码，产生`.o`文件。
4. 链接：将上述文件和库进行链接，包括重定位等一系列操作，生成可执行文件。

> 除了gcc，或许你还听说过clangd。

## 参考链接

[^punched-card]: 打孔卡 <https://zh.wikipedia.org/wiki/%E6%89%93%E5%AD%94%E5%8D%A1>