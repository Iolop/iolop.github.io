---
layout: post
title: CS:APP读书笔记-3-程序的机器级表示
date: 2024-03-13 21:31 +0800
categories: [CS:APP]
tags: [读书笔记]
math: true
---

# 第三章：程序的机器级表示

面对现在的可执行文件，我们千头万绪不知道该怎么去理解它。在Windows上，我们知道双击去运行它；Linux上，我们可以在命令行中通过`./file`的形式去执行。这一章，我们将会走进程序的机器级表示，来理解代码时如何被转变成CPU可以理解的模式的，我们又是如何来表示我们在源代码中的各种数据，而CPU又是如何访问它们。除此外，我们还将学习到我们常用的流程控制又是如何实现。以上这些内容采用C语言进行描述以及通过gcc编译出的各类中间文件进行解释，其他的类型比如虚拟机、JIT、解释器类型语言不在此列。



## CPU的演化

要理解可执行文件是怎么运行的，我们有必要先回头去看看CPU的演化过程。再最早时期，也许你曾看到书上提到一种打孔程序机[^punched-card]。这种形式后来被汇编代码所取代，因为汇编代码更容易被人们记忆。再后来，随着CPU的发展，我们拥有了更强的性能和更广阔的可用空间，随之演变的是更抽象的语言——我们现在常用的高级语言。简单的来看，我们把这三种演化的关系：机器码——汇编代码——高级语言，可以映射到如今的源代码到可执行代码的翻译之路上：编译——汇编——链接。

以前常说的x86，其实是Intel的32位处理器，可惜Intel没把握住64这个风口，让AMD先一步迈了出去，先有了amd64(注意和arm64不是同一个东西)，然后Intel跟进，出现了x86-64(强行更名)。

## 程序编码

通过如下命令，我们可以编译源代码，得到可执行代码。

```shell
gcc -Og -o hello hello.c
```

gcc是我们之前说的一整套工具，这是Linux上的默认编译器。通过上述命令，gcc会自动地帮助你执行一系列地命令来完成预处理、编译、汇编、链接过程。

1. 预处理：完成对源文件的拓展，插入头文件。
2. 编译：通过编译器，转化位汇编代码，产生`.s`文件。
3. 汇编：将汇编代码转化成二进制目标代码，产生`.o`文件。
4. 链接：将上述文件和库进行链接，包括重定位等一系列操作，生成可执行文件。

> 除了gcc，或许你还听说过clangd。

### 机器级代码

我们之前提到过，计算机系统内很重要的一个东西就是抽象，在机器级编程这一级别，我们拥有两个很重要的抽象。第一个是 *指令集体系/架构(Instruction Set Architecture, ISA)* ，程序的行为在ISA的抽象下，表现的像是顺序执行每一条指令。实际上硬件的设计非常复杂，很多时候它可以并发执行许多指令，但是可以保证效果和顺序指令保持一致。第二种抽象就是程序使用的内存地址是 *虚拟地址* 。系统提供的内存模型在这种抽象下像是一个巨大的数组。在下x86-64的情况下，我们需要知道以下几种在机器级代码中的小东西，这些东西通常被C语言的高级抽象隐藏，让我们免于直接面对他们的难处。除非你需要使用内联汇编。

- 程序计数器(Program Counter)：表示即将执行的下一条指令，通常在amd64中使用 *rip* 寄存器来指代。
- 通用寄存器(register)：用来存储64位的值，在x86-64架构中，常见的是RAX、RDX、RDI、RSI……这些寄存器用来存储状态、保存临时数据、变量等值。
- 条件寄存器：用来存储最近一次的运算中的状态信息，用来实现控制流中的条件变化。
- 一组向量寄存器：可以保存一个或者多个整数/浮点值。

> 不同的架构下，这些寄存器的名字不同。比如ARM64中，通用寄存器采用x0-x30的命名方式，程序计数器名字就是pc，而非rip。同样的，mips32、mips64这些架构更是不同。在后续的分析中，我们只会使用x86-64(amd64)架构。如果有兴趣，可以查阅这些架构的官方手册，观察和x86-64的不同。或者采用交叉编译的方式，编译出这些平台可用的ELF，在IDA中查看。

我们之前提到过，系统把内存视为一片连续的巨大字节数组。同样的，我们虽然在C里面拥有各种结构体，但是在内存里它们只是连续的数据而已，不会有任何区别。有无符号，指针类型这些都不在汇编代码的考虑范围内。那么在内存里，我们究竟有什么？它们包含着运行程序所必须的库函数、堆栈数据、程序本身的代码。在高位上，一般是留给内核所用，程序能用的往往是低位。目前来说，虽然我们拥有64位的寻址空间，但是一般只用48位即可满足需求。在这一大片空间内，操作系统负责管理虚拟的地址空间，将虚拟地址翻译到物理地址。

### 汇编代码示例

现在，我们对以下代码，使用 `gcc -Og -S bitset_func.c`，就会得到一个汇编代码。它的形式和源码有很大的不同，不过我们可以简单一窥其中的对应。

```c
#include <stdio.h>

void set_bit(int *v, int index) {
  int mask = 1 << index;
  *v &= mask;
}
```

```
set_bit:
	movl	$1, %eax
	movl	%esi, %ecx
	sall	%cl, %eax
	andl	%eax, (%rdi)
	ret
```
{: file='bitset_func.s'}

同时，如果我们使用 `gcc -Og -c bitset_func.c`，就会得到二进制格式的文件，这时内容已经基本无法肉眼辨别，这其中有一段序列正是我们在上面看到的汇编代码经过汇编后的形式，为了能得到映射，我们需要使用`objdump -d bitset_func.o`来观察这个二进制文件。

```
Disassembly of section .text:

0000000000000000 <set_bit>:
   0:   f3 0f 1e fa             endbr64 
   4:   b8 01 00 00 00          mov    $0x1,%eax
   9:   89 f1                   mov    %esi,%ecx
   b:   d3 e0                   shl    %cl,%eax
   d:   21 07                   and    %eax,(%rdi)
   f:   c3                      ret    
```
{: file='bitset_func.o'}

所以说，在二进制程序中，CPU知道的只是一串字节序列，它读取字节序列并且翻译到唯一映射的操作上，关于这种机器码和汇编代码的映射关系，可以查询各架构的ISA，比如x86-64的架构书就在这里[^x86-64ISA]。也许你注意到了一点，这些指令的长度或长或短，这就是复杂指令集的一种特征——不固定长度的指令。

这时候，我们需要另一个包含了 *main* 函数的 *bitset_main.c* 文件。我们使用`gcc -Og -c bitset_main.c`命令仍然单独编译，但是不链接。然后使用`objdump -d bitset_main.o`观察

```c
#include <stdio.h>
void set_bit(int *v, int index);
int main() {
  int value = 92;
  set_bit(&value, 6);
  return 0;
}
```

```
Disassembly of section .text:
0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64 
   4:   48 83 ec 18             sub    $0x18,%rsp
   8:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
   f:   00 00 
  11:   48 89 44 24 08          mov    %rax,0x8(%rsp)
  16:   31 c0                   xor    %eax,%eax
  18:   c7 44 24 04 5c 00 00    movl   $0x5c,0x4(%rsp)
  1f:   00 
  20:   48 8d 7c 24 04          lea    0x4(%rsp),%rdi
  25:   be 06 00 00 00          mov    $0x6,%esi
  2a:   e8 00 00 00 00          call   2f <main+0x2f>
  2f:   48 8b 44 24 08          mov    0x8(%rsp),%rax
  34:   64 48 2b 04 25 28 00    sub    %fs:0x28,%rax
  3b:   00 00 
  3d:   75 0a                   jne    49 <main+0x49>
  3f:   b8 00 00 00 00          mov    $0x0,%eax
  44:   48 83 c4 18             add    $0x18,%rsp
  48:   c3                      ret
```
{: file='bitset_main.o'}

注意，对比能看到，在进行`set_bit`调用的时候，位置是留空的。因为`call`指令的映射是`0x58`。

我们再次使用`gcc -Og -o bitset bitset_func.c bitset_main.c`。这一次，完成可执行文件的编译、汇编、链接。同样的，使用`objdump -d bitset`来观察编译结果。

```
0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64 
    114d:       48 83 ec 18             sub    $0x18,%rsp
    1151:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
    1158:       00 00 
    115a:       48 89 44 24 08          mov    %rax,0x8(%rsp)
    115f:       31 c0                   xor    %eax,%eax
    1161:       c7 44 24 04 5c 00 00    movl   $0x5c,0x4(%rsp)
    1168:       00 
    1169:       48 8d 7c 24 04          lea    0x4(%rsp),%rdi
    116e:       be 06 00 00 00          mov    $0x6,%esi
    1173:       e8 1f 00 00 00          call   1197 <set_bit>
    1178:       48 8b 44 24 08          mov    0x8(%rsp),%rax
    117d:       64 48 2b 04 25 28 00    sub    %fs:0x28,%rax
    1184:       00 00 
    1186:       75 0a                   jne    1192 <main+0x49>
    1188:       b8 00 00 00 00          mov    $0x0,%eax
    118d:       48 83 c4 18             add    $0x18,%rsp
    1191:       c3                      ret    
    1192:       e8 b9 fe ff ff          call   1050 <__stack_chk_fail@plt>

0000000000001197 <set_bit>:
    1197:       f3 0f 1e fa             endbr64 
    119b:       b8 01 00 00 00          mov    $0x1,%eax
    11a0:       89 f1                   mov    %esi,%ecx
    11a2:       d3 e0                   shl    %cl,%eax
    11a4:       21 07                   and    %eax,(%rdi)
    11a6:       c3                      ret   
```
{: file='bitset.o'}

此时，经过了链接的步骤，我们能发现，这里的`bit_set`已经被正确的填入了地址。这再次印证了我们之前提到的步骤：编译、汇编、链接。

> 在上述中展示的反汇编代码中，我们看到的格式或许和你知道的不太一样。这是因为Linux默认采用AT&T格式的汇编，这和Windows采用Intel格式不太一样，但是区别不大。有兴趣的朋友自行搜索这两者的差异即可。

## 参考链接

[^punched-card]: 打孔卡 <https://zh.wikipedia.org/wiki/%E6%89%93%E5%AD%94%E5%8D%A1>

[^x86-64ISA]: 参考手册 <https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html>
